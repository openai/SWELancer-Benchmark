import sys, os\n\nbase_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nsys.path.insert(0, base_path)\n\nimport imaplib\nimport email\nimport re\nimport random\nimport time\nfrom typing import Any\nfrom playwright._impl._page import Page\nfrom playwright._impl._browser import Browser\nfrom playwright._impl._locator import Locator\nfrom playwright.sync_api import sync_playwright\nfrom playwright.sync_api._context_manager import PlaywrightContextManager\n\nfrom utils.trace_cleaner import trace_cleaner\n\nmaster_email_address = "brighturing926+41510@gmail.com"\nmaster_app_password = "sijknxflhloopmta"\n\nclass EmailHandler:\n    def __init__(self, email_address, password) -> Any:\n        # Validate email and password input\n        if not self._validate_email(email_address):\n            raise ValueError("Invalid email address format.")\n        self.original_email = email_address\n        self.password = password\n\n        # Generate new random email using "+" prefix\n        random_suffix = random.randint(1000, 9999)\n        current_timestamp = int(time.time())\n        random_suffix = f"{current_timestamp}{random_suffix}"\n        self.new_email = email_address\n\n    def _validate_email(self, email_address) -> Any:\n        # Simple email validation\n        return bool(re.match(r"[^@]+@[^@]+\\.[^@]+", email_address))\n\n    def get_email_address(self) -> Any:\n        # Return the generated email with "+" suffix\n        return self.new_email\n\n    def check_for_otp(self) -> Any:\n        otp_code =  "344095"\n        # Connect to the Gmail server using IMAP\n        try:\n            mail = imaplib.IMAP4_SSL("imap.gmail.com")\n            mail.login(self.original_email, self.password)\n            mail.select("inbox")\n\n            # Fetch all unread emails\n            status, messages = mail.search(None, "UNSEEN")\n            if status != "OK":\n                print("No unread emails found.")\n                return None\n\n            email_ids = messages[0].split()\n            # Start from the latest email by reversing the list\n            email_ids = email_ids[::-1]  # Reverse order to process latest first\n\n            # Iterate over each email until OTP is found\n            for email_id in email_ids:\n                # Fetch the email by ID\n                status, msg_data = mail.fetch(email_id, '(RFC822)')\n                if status != "OK":\n                    print("Error fetching email.")\n                    continue\n\n                for response_part in msg_data:\n                    if isinstance(response_part, tuple):\n                        msg = email.message_from_bytes(response_part[1])\n\n                        # Check if the To address matches the generated new email\n                        if msg["To"] == self.new_email:\n                            # Extract OTP from the email body\n                            otp_code = self._extract_otp_from_email(msg)\n                            if otp_code:\n                                # Delete the email containing the OTP\n                                mail.store(email_id, '+FLAGS', '\\Deleted')\n                                mail.expunge()  # Permanently removes deleted emails from the mailbox\n                                # Logout and return OTP\n                                mail.close()\n                                mail.logout()\n                                return otp_code\n\n            # Logout if OTP not found in unread emails\n            mail.close()\n            mail.logout()\n            print("No OTP found in unread emails.")\n            return otp_code\n\n        except imaplib.IMAP4.error:\n            print("Failed to connect to Gmail. Please check your email address or password.")\n            return otp_code\n\n    def _extract_otp_from_email(self, msg) -> Any:\n        # Extract OTP code from the email content\n        if msg.is_multipart():\n            for part in msg.walk():\n                if part.get_content_type() == "text/plain":\n                    email_body = part.get_payload(decode=True).decode()\n                    otp_code = self._extract_otp(email_body)\n                    if otp_code:\n                        return otp_code\n        else:\n            email_body = msg.get_payload(decode=True).decode()\n            otp_code = self._extract_otp(email_body)\n            if otp_code:\n                return otp_code\n        return None\n\n    def _extract_otp(self, text) -> Any:\n        # Find a 6-digit code in the email body\n        match = re.search(r"\\b\\d{6}\\b", text)\n        return match.group(0) if match else None\n\ndef create_context(p: PlaywrightContextManager) -> tuple[Browser, Any, Page]:\n    # Launch chromiun and open new page\n    browser = p.chromium.launch(headless=True, args=[\n            "--disable-web-security",\n            "--disable-features=IsolateOrigins,site-per-process"\n        ],\n    )\n    context = browser.new_context()\n    page: Page = context.new_page()\n\n    # Step 1: Open expensify url\n    page.goto('https://dev.new.expensify.com:8082/')\n\n    return browser, context, page\n\ndef login_user(page: Page, user_email: str) -> tuple[str, str]:\n    # Step 2: Enter email and click continue\n    page.locator('input[type="email"]').fill(user_email)\n    page.locator('button[tabindex="0"]').click()\n\n    # Magic code entry\n    email_handle = EmailHandler(user_email, master_app_password)\n    page.wait_for_timeout(5000)\n    my_otp_code = email_handle.check_for_otp()\n    print(my_otp_code)\n\n    page.get_by_test_id("validateCode").fill(my_otp_code)\n\n    # Step 3: Click join button\n    try:\n        page.get_by_role("button", name="Sign in").click()\n\n    except Exception:\n        pass\n\ndef test_assign_to_me() -> None:\n    random_num = random.randint(111, 999)\n    newWorkspceName = f"mypersonalws{random_num}"\n    with sync_playwright() as p:\n        browser, context, page = create_context(p)\n        # Start tracing\n        context.tracing.start(screenshots=True, snapshots=True, sources=True)\n        try:\n            login_user(page, master_email_address)\n\n            page.get_by_label("Inbox").click()\n            page.get_by_role("button", name="Create").click()\n            page.get_by_text("Assign task").click()\n            page.get_by_role("textbox", name="Title").fill("Doing Things")\n            page.get_by_role("button", name="Next").click()\n            page.get_by_text("Assignee").click()\n\n            assign_to_me = page.get_by_text("Assign to me")\n            page.wait_for_timeout(1000)\n\n            assert assign_to_me.is_visible(), "Assign to me is not visible"\n        except Exception as e:\n            # We re-raise after the finally block ensures trace export\n            raise e\n        finally:\n            # Stop tracing and export\n            context.tracing.stop()\n            trace_path = '/app/expensify/user_tool/output_browser1.zip'\n            context.tracing.export(path=trace_path)\n            trace_cleaner(trace_path)\n\n            browser.close()\n\ndef create_new_workspace(page: Page, ws_name: str, first_name: str, last_name: str) -> str:\n    """Create a new workspace"""\n    random_num = random.randint(111, 999)\n    new_workspace_name = f"{ws_name}{random_num}"\n    page.get_by_label("New workspace").click()\n    new_created_ws1 = get_newly_created_ws(page, first_name, last_name)\n\n    new_created_ws1.click()\n    page.get_by_role("textbox", name="Name").click()\n    page.get_by_role("textbox", name="Name").fill(new_workspace_name)\n    page.wait_for_timeout(1000)\n    page.get_by_role("button", name="Save").click()\n    page.wait_for_timeout(1000)\n    # page.get_by_label("Back").click()\n    return new_workspace_name\n\ndef get_newly_created_ws(page: Page, first_name: str, last_name: str) -> Locator | None:\n    """\n    Check for the latest created workspace to be used for testing\n    """\n    buttons = page.get_by_test_id("WorkspacePageWithSections").locator(f"text={first_name} {last_name}'s Workspace")\n    button_count = buttons.count()\n\n    latest_button = None\n    max_number = -1\n    for i in range(button_count):\n        button_text = buttons.nth(i).inner_text()\n        # Find the number at the end of the button text using regex\n        match = re.search(r"\\d+$", button_text)\n        if match:\n            number = int(match.group())\n            if number > max_number:\n                max_number = number\n                latest_button = buttons.nth(i)\n\n    if latest_button:\n        return latest_button\n    else:\n        print("No button with a numeric suffix found.")\n\ndef get_names_for_existing_account(page: Page) -> tuple[str, str]:\n    """\n    Retrive first and last name from the account profile\n    """\n    page.get_by_label("My settings").click()\n    try:\n        page.get_by_label("Close").click(timeout=1000)\n    except Exception:\n        pass\n    page.get_by_role("menuitem", name="Profile").click()\n    page.get_by_text("Display name").click()\n    f_name = page.get_by_role("textbox", name="First name")\n    l_name = page.get_by_role("textbox", name="Last name")\n    page.wait_for_timeout(2000)\n    # page.keyboard.down("Escape")\n    page.get_by_label("Back").click()\n\n    return f_name.input_value(), l_name.input_value()\n