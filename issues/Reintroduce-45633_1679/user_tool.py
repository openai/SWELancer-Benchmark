import sys, os\n\nbase_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nsys.path.insert(0, base_path)\n\nimport time\nfrom playwright.sync_api import Page, expect, sync_playwright\nimport imaplib\nimport email\nimport re\nfrom email.header import decode_header\nimport pytest\nfrom utils.trace_cleaner import trace_cleaner\n\nGMAIL_NAME = "rgulraiz2000"\nGMAIL_APP_PASSWORD = "kepw uquj myoa npvj"\n\ndef get_test_user_info(seed = None, first_name = None, last_name = None):\n    if first_name is None:\n        first_name = GMAIL_NAME\n\n    if last_name is None:\n        last_name = ""\n\n    email = f"{GMAIL_NAME}+{seed}@gmail.com" if seed is not None else f"{GMAIL_NAME}@gmail.com"\n    \n    return {"email": email, "password": GMAIL_APP_PASSWORD, "first_name": first_name, "last_name": last_name}\n\ndef get_magic_code(user_email, password, retries=5, delay=5):\n    # Connect to the server\n    imap = imaplib.IMAP4_SSL("imap.gmail.com")\n    imap.login(user_email, password)\n\n    for _ in range(retries):\n        imap.select("inbox")\n        status, messages = imap.search(None, '(UNSEEN SUBJECT "Expensify magic sign-in code:")')\n\n        if status == "OK":\n            email_ids = messages[0].split()\n\n            if email_ids:\n                latest_email_id = email_ids[-1]\n                status, msg_data = imap.fetch(latest_email_id, "(RFC822)")\n\n                for response_part in msg_data:\n                    if isinstance(response_part, tuple):\n                        msg = email.message_from_bytes(response_part[1])\n                        subject, encoding = decode_header(msg["Subject"])[0]\n                        if isinstance(subject, bytes):\n                            subject = subject.decode(encoding or "utf-8")\n\n                        # Search for the magic code in the subject\n                        match = re.search(r"Expensify magic sign-in code: (\d+)", subject)\n                        if match:\n                            code = match.group(1)\n                            imap.logout()\n                            return code\n            else:\n                print("No unread emails found with the subject. Retrying...")\n        else:\n            print("Failed to retrieve emails. Retrying...")\n\n        # Wait for the specified delay before trying again\n        time.sleep(delay)\n\n    imap.logout()\n    print("Max retries reached. Email not found.")\n    return None\n\ndef login_user(page, user_info, URL):\n    page.goto(URL)\n    page.wait_for_timeout(3000)\n\n    page.get_by_role("textbox", name="Phone or email").click()\n    page.get_by_role("textbox", name="Phone or email").fill(user_info["email"])\n    page.get_by_role("button", name="Continue").click()\n    \n    join_button = page.get_by_role("button", name="Join")\n    validate_code_input = page.locator('input[data-testid="validateCode"]')\n    validate_code_input = page.locator('input[name="validateCode"]')\n    validate_code_input = page.locator('input[autocomplete="one-time-code"][maxlength="6"]')\n\n    expect(validate_code_input).to_be_visible()\n\n    if (join_button.is_visible()):\n        join_button.click(timeout=3000)\n    else:\n        # magic_code = get_magic_code(user_info["email"], user_info["password"], retries=6, delay=5)\n        magic_code = "123456"\n        validate_code_input.fill(magic_code)\n\n    page.wait_for_timeout(3000)\n\ndef test_track_sound():\n    with sync_playwright() as p:\n        timestamp = int(time.time())\n\n        browser = p.chromium.launch(headless=True,args=[\n            "--disable-web-security",\n            "--disable-features=IsolateOrigins,site-per-process"\n        ])\n        context = browser.new_context()\n\n        # Start tracing\n        context.tracing.start(screenshots=True, snapshots=True, sources=True)\n\n        try:\n            page = context.new_page()\n\n            URL = "https://dev.new.expensify.com:8082/"\n\n            # create user\n            user_info = get_test_user_info(first_name="John", last_name="T")\n            login_user(page, user_info, URL)\n            page.wait_for_timeout(4000)\n            page.get_by_label("Start chat (Floating action)").click()\n            page.get_by_label("Track expense").click()\n            page.get_by_role("button", name="Got it").click()\n            page.get_by_label("Manual").click()\n            page.get_by_placeholder("0").fill("1000")\n            page.locator("#numPadContainerView").get_by_role("button", name="Next").click()\n            page.get_by_label("Show more").click()\n            page.get_by_role("menuitem", name="Merchant").click()\n            page.get_by_role("textbox", name="Merchant").fill("merchant_1")\n            page.get_by_role("button", name="Save").click()\n\n            # Override the create method of the Sound object\n            page.evaluate("""\n              () => {\n                window.soundPlayCount = 0;\n                const originalPlay = Sound.prototype.create;\n                Sound.prototype.create = function() {\n                  originalPlay.call(this);\n                  window.soundPlayCount++;\n                };\n              }\n            """)\n\n            page.get_by_role("button", name="Track expense").click()\n            page.wait_for_timeout(2000)\n\n            # Check how many times the sound was played\n            sound_play_count = page.evaluate("window.soundPlayCount")\n\n            # expect sound to be played once\n            assert sound_play_count == 1, "Sound was not played once"\n\n        except Exception as e:\n            raise e\n        finally:\n            # Stop tracing and export\n            context.tracing.stop()\n            trace_path = "/app/expensify/user_tool/output_browser1.zip"\n            context.tracing.export(path=trace_path)\n            trace_cleaner(trace_path)\n            context.close()\n            browser.close()\n