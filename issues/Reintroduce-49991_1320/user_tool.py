import sys, os\n\nbase_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nsys.path.insert(0, base_path)\n\nimport email\nimport imaplib\nimport re\nimport secrets\nimport string\nimport time\nfrom email.header import decode_header\n\nimport pytest\nfrom playwright.async_api import Page, TimeoutError, async_playwright, expect\nfrom utils.trace_cleaner import trace_cleaner\n\nUSER_NAME = "xecuycismfsga+49991"\nUSER_EMAIL = f"{USER_NAME}@gmail.com"\nPASSWORD = "uwgb zzoc cofa kaaq"\nNOW = int(time.time())\n\ndef get_magic_code(\n    user_email: str, password: str, current_timestamp: int, retries=5, delay=3\n):\n    imap = imaplib.IMAP4_SSL("imap.gmail.com")\n    imap.login(user_email, password)\n\n    for _attempt in range(retries):\n        print(f"Attempt {_attempt}")\n\n        # Don't wait on the first attempt\n        if _attempt > 0:\n            print(f"Waiting {delay} seconds before next attempt...")\n            time.sleep(delay)\n\n        imap.select("inbox")\n        status, messages = imap.search(\n            None, '(UNSEEN SUBJECT "Expensify magic sign-in code:")'\n        )\n\n        if status == "OK":\n            email_ids = messages[0].split()\n\n            if email_ids:\n                latest_email_id = email_ids[-1]\n                status, msg_data = imap.fetch(latest_email_id, "(RFC822)")\n\n                for response_part in msg_data:\n                    if isinstance(response_part, tuple):\n                        msg = email.message_from_bytes(response_part[1])\n\n                        # Get email timestamp and convert to UTC\n                        email_date = msg.get("Date")\n                        email_timestamp = email.utils.mktime_tz(\n                            email.utils.parsedate_tz(email_date)\n                        )\n\n                        # Convert current_timestamp to UTC\n                        current_utc = time.time()\n\n                        # Mark the email as seen so we don't process it again\n                        imap.store(latest_email_id, "+FLAGS", "\\Seen")\n\n                        print(\n                            f"Email time: {email_timestamp}, Current time: {current_utc}"\n                        )\n\n                        # If email is too old, wait and try again\n                        if email_timestamp < current_timestamp:\n                            print(\n                                f"Found old email from {email_date}, waiting for new one..."\n                            )\n                            break  # Break the response_part loop\n\n                        subject, encoding = decode_header(msg["Subject"])[0]\n                        if isinstance(subject, bytes):\n                            subject = subject.decode(encoding or "utf-8")\n\n                        match = re.search(\n                            r"Expensify magic sign-in code: (\\d+)", subject\n                        )\n                        if match:\n                            code = match.group(1)\n                            imap.logout()\n                            return code\n\n    imap.logout()\n    print("Max retries reached. Email not found.")\n    return None\n\ndef generate_random_string(length=12):\n    # Generate a random base64 string\n    random_bytes = secrets.token_bytes(length)\n    base64_string = secrets.base64.b64encode(random_bytes).decode("utf-8")\n\n    # Filter to include only alphanumeric characters\n    alphanumeric_string = "".join(\n        filter(lambda x: x in string.ascii_letters + string.digits, base64_string)\n    )\n\n    # Return the first `length` characters of the filtered string\n    return alphanumeric_string[:length]\n\nasync def login_or_create_user(page: Page, user_email: str, password: str):\n    await page.get_by_test_id("username").fill(user_email)\n    await page.get_by_role("button", name="Continue").click()\n\n    try:\n        await page.get_by_role("button", name="Join").wait_for(\n            state="visible", timeout=2000\n        )\n        firstname, lastname = generate_random_string(6), generate_random_string(6)\n        await create_user(page, firstname, lastname)\n    except TimeoutError:\n        await login(page, user_email, password)\n\n    await page.get_by_label("Inbox").wait_for(state="visible", timeout=5000)\n\nasync def login(page: Page, user_email: str, password: str):\n    # magic_code = get_magic_code(user_email, password, NOW, retries=3, delay=3)\n    magic_code = "111111"\n    await page.get_by_role("textbox").fill(magic_code)\n\nasync def create_user(page: Page, firstname: str, lastname: str):\n    await page.get_by_role("button", name="Join").click()\n\n    # Update profile\n    await page.get_by_text("Track and budget expenses").click()\n    await page.get_by_role("textbox", name="First name").fill(firstname)\n    await page.get_by_role("textbox", name="Last name").fill(lastname)\n    await page.get_by_role("button", name="Continue").click()\n\n    await page.get_by_label("Back").first.click()\n    await close_button_if_present(page)\n\nasync def leave_group_chat(page: Page):\n    if await page.get_by_text(USER_NAME).first.is_visible():\n        print("Leaving group chat")\n\n        # Open group details\n        await page.get_by_text(USER_NAME).first.click()\n        await page.locator(\n            f'div[data-testid="DisplayNamesWithTooltip"]:has-text("{USER_NAME}")'\n        ).last.click()\n        await page.get_by_label("Leave").click()\n        await page.get_by_label("Back").first.click()\n\n    else:\n        print("No group chat to leave")\n\nasync def close_button_if_present(page: Page):\n    """\n    Occasionally, there is a close button that prevents any clicks on the page as\n    it covers most of the screen. This button cannot be seen visually.\n    """\n    close_button = page.locator('button[aria-label="Close"]')\n    count = await close_button.count()\n\n    for i in range(count):\n        button = close_button.nth(i)\n        if await button.is_visible():\n            await button.click()\n\n@pytest.mark.asyncio  # ensure you have pytest-asyncio installed\nasync def test_delete_task():\n    async with async_playwright() as p:\n        proxy = {"server": "http://127.0.0.1:8080/"} \n        args = ["--disable-web-security", "--disable-features=IsolateOrigins,site-per-process"]\n\n        browser = await p.chromium.launch(\n            headless=True, slow_mo=500, proxy=proxy, args=args\n        )  # Adds 1 second delay between actions\n        phone = p.devices["Galaxy S9+"]\n        context = await browser.new_context(**phone)\n\n        # Start tracing\n        await context.tracing.start(screenshots=True, snapshots=True, sources=True)\n\n        try:\n            page = await context.new_page()\n\n            # login\n            await page.goto("https://dev.new.expensify.com:8082/")\n            await login_or_create_user(page, USER_EMAIL, PASSWORD)\n\n            # Disable focus mode (we need all chats to be visible)\n            await page.get_by_label("My settings").click()\n            await page.get_by_label("Preferences").click()\n            await page.get_by_text("Priority mode").click()\n            await page.get_by_test_id("selection-list").get_by_label("Most recent").click()\n            await page.get_by_label("Back").first.click()\n            await page.get_by_label("Inbox").click()\n            await close_button_if_present(page)\n            # Leave group chat if present\n            await leave_group_chat(page)\n\n            # create group chat\n            await close_button_if_present(page)\n            await page.get_by_label("Start chat (Floating action)").click()\n            await page.get_by_label("Start chat", exact=True).click()\n            for user_email in [\n                f"{USER_NAME}_0@gmail.com",\n                f"{USER_NAME}_1@gmail.com",\n            ]:\n                await page.get_by_test_id("selection-list-text-input").fill(user_email)\n                await page.get_by_role("button", name="Add to group").click()\n            await page.get_by_role("button", name="Next").click()\n            await page.get_by_role("button", name="Start group").click()\n            await page.get_by_label("Back").first.click()\n            await page.get_by_label("Inbox").wait_for(state="visible")\n            await page.reload()\n\n            # Create task\n            await page.get_by_text(USER_NAME).first.click()\n            await page.get_by_label("Create").last.click()\n            await page.get_by_label("Assign task").click()\n            await page.get_by_role("textbox", name="Title").fill("Title")\n            await page.get_by_role("button", name="Next").click()\n            await page.get_by_role("button", name="Confirm task").click()\n\n            # Open task details\n            await page.get_by_role("button", name="Task").last.click()\n\n            # Open task menu (click on task header)\n            await page.locator(\n                'div[data-testid="DisplayNamesWithTooltip"]:has-text("Title")'\n            ).click()\n\n            # Delete the task\n            await page.get_by_test_id("ReportDetailsPage").get_by_label("Delete").click()\n            await page.get_by_role("button", name="Delete").click()\n            await page.wait_for_timeout(1000)\n\n            await page.get_by_role("button", name="Back").click()\n            await expect(page.get_by_text("[Deleted task]").first).not_to_be_visible()\n\n            await leave_group_chat(page)\n\n        except Exception as e:\n            print("Test failed. Saving trace before re-raising exception.")\n            raise e\n        finally:\n            # Stop tracing and save the trace\n            await context.tracing.stop(path="/app/expensify/user_tool/output_browser1.zip")\n            trace_cleaner("/app/expensify/user_tool/output_browser1.zip")\n            await context.close()\n            await browser.close()\n